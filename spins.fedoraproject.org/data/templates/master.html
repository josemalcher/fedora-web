<?python
import simplejson
import urllib
import re
from operator import itemgetter
import random
from types import NoneType


class Torrents(object):

    prerelease_re = re.compile('-(alpha|beta|snap|preview)([0-9]*)$', re.I)
    non_release_re = re.compile('(alpha|beta|snap|preview)', re.I)
    prerelease_order = ['alpha', 'beta', 'snap', 'preview']
    spins_matches = ['broffice', 'edu', 'math', 'kde', 'xfce', 'lxde', 'aos', 'developer', 'fel', 'games']
    archlist = ['i386', 'i586', 'i686', 'ix86', 'ppc', 'x86_64', 'source', 'Source']

    def __init__(self):
        self._torrents = None

    @property
    def torrents(self):
        if not self._torrents:
            fo = urllib.urlopen('http://torrent.fedoraproject.org/stats/current-stats.json')
            self._torrents = simplejson.load(fo)
            fo.close()
        return self._torrents

    def parse_torrent_name(self, name):
        for arch in self.archlist:
            arch_pos = name.find('-%s-' % arch)
            if arch_pos != -1:
                release = name[0:arch_pos]
                spin = name[arch_pos + len(arch) + 2:]
                return spin, release, arch
        raise Exception('No known architecture in the spin name: %s' % name)

    def specific_spin(self, name, release=None, arch=None, latest=True):
        '''
        :arg name: the name of a spin
        :kwarg release: release of Fedora to retrieve for
        :kwarg arch: Limit to a specific arch
        :kwarg latest: If True, only return the latest spin (latest prerelease,
            or the final) in the list.  If False, return the whole list.  Note,
            when multiple archs are being returned the latest version per arch
            could be different.
        :returns: a list of spins meeting the criteria
        '''
        if not isinstance(release, basestring):
            release = '%s' % release
        spins = []

        #print "name:", name
        #print "release:", release
        #print "pattern:", pattern
        #for row in self.torrents:
        for row in self.torrents:
            t_name, t_release, t_arch = self.parse_torrent_name(row['name'])
            if (name.lower() in t_name.lower()):
                if release and (release.lower() not in t_release.lower()):
                    continue
                if arch and (arch.lower() != t_arch.lower()):
                    continue
                spins.append(row)

        if latest:
            latest = {}
            for spin in spins:
                # Get arch and version
                # if version is later than current ver for arch, add it in
                t_name, t_release, t_arch = self.parse_torrent_name(spin['name'])
                # Parse out prerelease string if any
                match = self.prerelease_re.search(t_release)
                # No match means we're on final
                if not match:
                    # Place final one later than the last prerelease
                    latest[t_arch] = (spin, len(self.prerelease_order), 1)
                    continue
                else:
                    prerelease = match.group(1).lower()
                    prerelease_seq = match.group(2) or '0'
                    if prerelease_seq:
                        prerelease_seq = int(prerelease_seq)
                    prerelease_index = self.prerelease_order.index(prerelease)

                # Get our saved version
                l = latest.get(t_arch, None)
                if l:
                    if prerelease_index < l[1]:
                        # prerelease came before what we have so far
                        continue
                    elif prerelease_index == l[1]:
                        if prerelease_seq <= l[2]:
                            # prerelease is a lower sequence than what we
                            # have now (like snap1 vs snap2)
                            continue
                latest[t_arch] = (spin, prerelease_index, prerelease_seq)
            spins = [s[0] for s in latest.values()]
        return spins

    # needed functions
    def matches_a_spin(self, name):
        '''Decide if a spin is of a release.

        :returns: True if the name is a spin and in a released Fedora.
        '''
        if self.non_release_re.search(name):
            return False    
        for part in self.spins_matches:
            if part in name.lower():
                return True
        return False


    def gettorrentinfo(self, name, release, value):
        for row in self.torrents:
            if name in row['name'].lower() and release in row['name']:
                return row[value]


    def gettorrentsize(self, name, release):
        for spin in self.torrents:
            if spin['name'].lower().endswith(name) and release in spin['name']:
                return spin['size']


    def getrandomtorrent(self, list):
        return random.randint(0, len(list)-1)

def formatsize(n, format='%0.2f'):
    return format % (n / 1024.0**2)


torrents = Torrents()
release = '12'
arch = 'i686'

def formatsize(n, format='%0.2f'):
    # this is awful.
    if isinstance(n, NoneType):
         n = 1
    #print "type: ", type(n)
    return format % (n / 1024.0**2)

# this gets all the current spins torrents
spins = []
for t_dict in torrents.torrents:
    # Ugly hack, this should probably be be refactored.
    if not t_dict['name'].startswith('Fedora-%s-i686' % release):
        continue
    if torrents.matches_a_spin(t_dict['name']):
        if release in t_dict['name']:
            spins.append(t_dict)


#sort by most downloaded
most_downloaded = sorted(spins,key=itemgetter('completed'), reverse=True)
# sort by alphabetical
alphabetical = sorted(spins, key=itemgetter('name'))


#data used on sidebar, for featured-spin section
sdata_feature = {
    'broffice': "Brazilian localized spin that provides the legal brand for OpenOffice.org in Brazil.",
    'edu': "A special selection of applications related to educational and scientific purposes.",
    'math': "This is math",
    'kde': "A complete, modern desktop built using the K Desktop Environment (KDE).",
    'xfce': "A complete, well-integrated Xfce desktop.",
    'lxde': "This is lxde",
    'aos': "A scaled-down version of Fedora with a small footprint for running an appliance.",
    'developer': "This is developer",
    'fel': "Fedora's high-end hardware design and simulation platform.",
    'games': "A perfect show-case of the best games available in Fedora.",
    'art': "The ultimate free & open source art studio - tailored for graphic designers.",
    'desktop': "The Desktop spin of Fedora is the primary spin as provided on fedoraproject.org.",
    'security': "Security analysis tools."
}


?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
  xmlns:py="http://genshi.edgewall.org/"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  py:strip="">
  <head py:match="head" py:attrs="select('@*')">
    <xi:include href="css.html" />
    <xi:include href="js.html" />
    <meta py:replace="select('*|text()')" />
  </head>
  <py:match path="body" once="true">
  <body py:attrs="select('@*')">
    <div id="wrapper">
      <xi:include href="head.html" />
      <xi:include href="sidebar.html" />
      <div id="content">
        ${select('*')}
      </div>
    </div>
    <xi:include href="foot.html" />
  </body>
  </py:match>
</html>
